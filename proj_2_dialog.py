# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BasicCalculationsDialog
                                 A QGIS plugin
 This plugin calculates the surface area and the difference in height.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-30
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Alicja Adamów-Bielkowicz, Artur Urban, Mateusz Trojanowski
        email                : alicja.adamow-bielkowicz.stud@pw.edu.pl, artur.urban.stud@pw.edu.pl, mateusz.trojanowski3.stud@pw.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import csv

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import QgsProject, QgsGeometry, QgsPointXY, Qgis, QgsWkbTypes, QgsFeature, QgsField, QgsVectorLayer, QgsCoordinateReferenceSystem, QgsCoordinateTransformContext
from qgis.utils import iface

# Wczytanie pliku .ui, aby PyQt mógł wypełnić wtyczkę elementami z Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'proj_2_dialog_base.ui'))


class BasicCalculationsDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(BasicCalculationsDialog, self).__init__(parent)
        # Konfiguracja interfejsu użytkownika z Designerem przez FORM_CLASS.
        self.setupUi(self)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.przycisk_przew.clicked.connect(self.oblicz_roznice_wysokosci)
        self.przycisk_pole.clicked.connect(self.oblicz_powierzchnie)
        self.przycisk_czysc.clicked.connect(self.czysc_wyniki)
        self.przycisk_zaznacz.clicked.connect(self.zaznacz_nowe_obiekty)
        self.poligon.clicked.connect(self.utworz_poligon)
        self.przycisk_wczytaj.clicked.connect(self.wczytaj_plik)

        self.strefa.setVisible(False)
        self.label_strefa.setVisible(False)

        self.uklad.currentIndexChanged.connect(self.zmien_widocznosc_strefy)

    def zmien_widocznosc_strefy(self):
        # Sprawdzenie, czy wybrano "EPSG:2000"
        if self.uklad.currentText() == "2000":
            self.label_strefa.setVisible(True)
            self.strefa.setVisible(True)
        else:
            self.label_strefa.setVisible(False)
            self.strefa.setVisible(False)

    def wczytaj_plik(self):
        plik, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Wybierz plik", "", "Pliki tekstowe (*.txt *.csv)")
        if not plik:
            return

        wybrany_uklad = self.uklad.currentText()
        if wybrany_uklad == "1992":
            crs = QgsCoordinateReferenceSystem("EPSG:2180")
        elif wybrany_uklad == "2000":
            strefa = self.strefa.currentText()
            crs = QgsCoordinateReferenceSystem(f"EPSG:217{int(strefa) + 1}")
        else:
            crs = QgsCoordinateReferenceSystem("EPSG:2180")

        # Utwórz warstwę punktową
        nowa_warstwa = QgsVectorLayer("Point", "punkty", "memory")
        nowa_warstwa.setCrs(crs)

        with open(plik, newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile, delimiter=' ', quotechar='"')
            self.tabela_wsp.setRowCount(0)
            for row_index, row_data in enumerate(reader):
                if len(row_data) >= 2:  # Sprawdź czy są przynajmniej dwie kolumny
                    self.tabela_wsp.insertRow(row_index)
                    # Użyj tylko dwóch pierwszych kolumn
                    for column_index, data in enumerate(row_data[:2]):
                        self.tabela_wsp.setItem(
                            row_index, column_index, QtWidgets.QTableWidgetItem(data))

        with open(plik, newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile, delimiter=' ', quotechar='"')
            for row_data in reader:
                if len(row_data) >= 2:  # Sprawdź czy są przynajmniej dwie kolumny
                    try:
                        x = float(row_data[0])
                        y = float(row_data[1])
                    except ValueError:
                        iface.messageBar().pushMessage(
                            "Błąd", "Nieprawidłowy format danych w pliku.", level=Qgis.Warning)
                        return
                    punkt = QgsPointXY(x, y)
                    cecha = QgsFeature()
                    cecha.setGeometry(QgsGeometry.fromPointXY(punkt))
                    nowa_warstwa.dataProvider().addFeatures([cecha])

        # Zapisz zmiany na warstwie
        nowa_warstwa.updateExtents()

        # Dodaj warstwę do projektu
        projekt = QgsProject.instance()
        projekt.addMapLayer(nowa_warstwa)

        # Odśwież widok mapy
        iface.mapCanvas().refresh()

    def oblicz_roznice_wysokosci(self):
        # Pobranie wybranej warstwy
        warstwa = self.mMapLayerComboBox.currentLayer()
        if not warstwa:
            iface.messageBar().pushMessage("Błąd", "Nie wybrano warstwy.", level=Qgis.Warning)
            return

        # Pobranie wybranych obiektów
        wybrane_obiekty = warstwa.selectedFeatures()
        if len(wybrane_obiekty) != 2:
            iface.messageBar().pushMessage(
                "Błąd", "Wybierz dokładnie 2 punkty.", level=Qgis.Warning)
            return

        # Wyciągnięcie wysokości z wybranych obiektów
        try:
            h1 = float(wybrane_obiekty[0]['wysokosc'])
            h2 = float(wybrane_obiekty[1]['wysokosc'])
        except KeyError:
            iface.messageBar().pushMessage(
                "Błąd", "Brak pola wysokości 'wysokosc' w punktach.", level=Qgis.Critical)
            return

        przewyzszenie = round(h2 - h1, 3)

        # Wyświetlenie wyniku
        self.label_wys.setText(f"{przewyzszenie} m")
        iface.messageBar().pushMessage("Różnica wysokości",
                                       f"Różnica wysokości między wybranymi punktami wynosi: {przewyzszenie} m", level=Qgis.Success)

    def oblicz_powierzchnie(self):
        # Pobranie wybranej warstwy
        warstwa = self.mMapLayerComboBox.currentLayer()
        if not warstwa:
            iface.messageBar().pushMessage("Błąd", "Nie wybrano warstwy.", level=Qgis.Warning)
            return

        # Pobranie wybranych obiektów
        wybrane_obiekty = warstwa.selectedFeatures()
        if len(wybrane_obiekty) < 3:
            iface.messageBar().pushMessage(
                "Błąd", "Wybierz co najmniej 3 punkty.", level=Qgis.Warning)
            return

        # Pobranie współrzędnych wybranych punktów
        punkty = []
        identyfikatory_punktow = []
        for f in wybrane_obiekty:
            geom = f.geometry()
            if geom.isEmpty() or QgsWkbTypes.geometryType(geom.wkbType()) != QgsWkbTypes.PointGeometry:
                iface.messageBar().pushMessage(
                    "Błąd", "Wybrany obiekt nie jest punktem.", level=Qgis.Warning)
                return
            punkt = geom.asPoint()
            punkty.append(QgsPointXY(punkt.x(), punkt.y()))
            identyfikatory_punktow.append(f.id())

        # Obliczenie powierzchni przy użyciu wzoru Gaussa
        powierzchnia = self.powierzchnia_gaussa(punkty)

        # Wybór jednostki na podstawie wyboru użytkownika z rozwijanej listy
        jednostka = self.comboBox.currentText()

        # Przeliczenie powierzchni na wybraną jednostkę, jeśli to konieczne
        if jednostka == "ar":
            powierzchnia /= 100
        elif jednostka == "ha":
            powierzchnia /= 10000

        # Zaokrąglenie wyniku do 3 miejsc po przecinku
        powierzchnia = round(powierzchnia, 3)

        # Wyświetlenie wyniku
        iface.messageBar().pushMessage(
            "Wynik",
            f"Powierzchnia wielokąta o wierzchołkach w punktach {', '.join(map(str, identyfikatory_punktow))} wynosi: {powierzchnia} {jednostka}",
            level=Qgis.Success
        )
        self.label_pole.setText(f"{powierzchnia} {jednostka}")

    def czysc_wyniki(self):
        """Czyszczenie wyników."""
        self.label_wys.clear()
        self.label_pole.clear()
        self.label_poligon.clear()
        iface.messageBar().clearWidgets()

    def zaznacz_nowe_obiekty(self):
        """Pozwala użytkownikowi zaznaczyć nowe obiekty."""
        warstwa = self.mMapLayerComboBox.currentLayer()
        if not warstwa:
            iface.messageBar().pushMessage("Błąd", "Nie wybrano warstwy.", level=Qgis.Warning)
            return

        warstwa.removeSelection()  # Usuń obecne zaznaczenie
        iface.messageBar().pushMessage(
            "Informacja", "Wybierz nowe obiekty na mapie.", level=Qgis.Info)

    def powierzchnia_gaussa(self, punkty):
        n = len(punkty)
        powierzchnia = 0.0

        for i in range(n):
            x1, y1 = punkty[i].x(), punkty[i].y()
            x2, y2 = punkty[(i + 1) % n].x(), punkty[(i + 1) % n].y()
            powierzchnia += x1 * y2 - x2 * y1

        return abs(powierzchnia) / 2

    def utworz_poligon(self, punkty):
        # Pobranie wybranej warstwy
        warstwa = self.mMapLayerComboBox.currentLayer()
        if not warstwa:
            iface.messageBar().pushMessage("Błąd", "Nie wybrano warstwy.", level=Qgis.Warning)
            return

        # Pobranie wybranych obiektów
        wybrane_obiekty = warstwa.selectedFeatures()
        if len(wybrane_obiekty) < 3:
            iface.messageBar().pushMessage(
                "Błąd", "Wybierz co najmniej 3 punkty.", level=Qgis.Warning)
            return

        # Pobranie współrzędnych wybranych punktów
        punkty = []
        identyfikatory_punktow = []
        for f in wybrane_obiekty:
            geom = f.geometry()
            if geom.isEmpty() or QgsWkbTypes.geometryType(geom.wkbType()) != QgsWkbTypes.PointGeometry:
                iface.messageBar().pushMessage(
                    "Błąd", "Wybrany obiekt nie jest punktem.", level=Qgis.Warning)
                return
            punkt = geom.asPoint()
            punkty.append(QgsPointXY(punkt.x(), punkt.y()))
            identyfikatory_punktow.append(f.id())

        # Utworzenie poligonu
        poligon = QgsGeometry.fromPolygonXY(
            [[QgsPointXY(p.x(), p.y()) for p in punkty]])

        # Pobranie CRS z warstwy punktowej
        crs = warstwa.crs()

        # Utworzenie nowej warstwy wektorowej do przechowywania poligonu
        nowa_warstwa = QgsVectorLayer(
            "Polygon", "Poligon", "memory")
        nowa_warstwa.setCrs(crs)
        projekt = QgsProject.instance()
        projekt.addMapLayer(nowa_warstwa)

        # Rozpoczęcie edycji warstwy
        nowa_warstwa.startEditing()

        # Utworzenie nowego obiektu cechowego i dodanie go do warstwy
        cecha = QgsFeature()
        cecha.setGeometry(poligon)
        nowa_warstwa.addFeature(cecha)

        # Zakończenie edycji warstwy
        nowa_warstwa.commitChanges()

        # Powierzchnia policzona z Gaussa
        #powierzchnia = self.powierzchnia_gaussa(punkty)

        # Sprawdzenie atrybutu geometry().area()
        pole_poligonu = round(poligon.area(), 3)
        iface.messageBar().pushMessage(
            "Wynik",
            f"Pole poligonu o wierzchołkach w punktach {', '.join(map(str, identyfikatory_punktow))} wynosi: {pole_poligonu}",
            level=Qgis.Success
        )
        self.label_poligon.setText(f"{pole_poligonu} m²")
